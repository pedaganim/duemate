# Import Configuration for Existing Resources
#
# ‚ö†Ô∏è  IMPORTANT: This file is disabled by default (*.example extension)
# 
# This file contains import blocks to automatically import existing AWS resources
# into Terraform state. This prevents "resource already exists" errors when running
# terraform apply on infrastructure that was previously created.
#
# ‚ö†Ô∏è  DO NOT USE FOR NEW DEPLOYMENTS
# If you're deploying to AWS for the first time, you DO NOT need this file.
# Import blocks will FAIL if the resources don't exist in AWS yet.
#
# üìã WHEN TO USE THIS FILE:
# Only use this file when you have existing AWS resources that need to be imported
# into Terraform state, such as:
# - Resources created manually in the AWS Console
# - Resources from a previous deployment without Terraform state
# - Recovering from lost Terraform state
#
# üîß HOW TO USE:
# 1. Rename this file from import.tf.example to import.tf
# 2. Run: terraform plan
# 3. Terraform will automatically import existing resources
# 4. After successful import, rename back to import.tf.example or delete
#
# Import blocks are supported in Terraform 1.5.0+
#
# When you run `terraform plan` or `terraform apply`, Terraform will automatically
# import these resources if they exist in AWS but not in the state file.
# If a resource doesn't exist in AWS, the import will FAIL with an error.

# Data source to get current AWS account ID
data "aws_caller_identity" "current" {}

# Local variables for import blocks
# Note: We need to redefine this here because import blocks cannot reference
# locals from main.tf (they are evaluated in a different phase)
locals {
  import_name_prefix = var.customer_name != null ? "${var.project_name}-${var.customer_name}-${var.environment}" : "${var.project_name}-${var.environment}"
}

# IAM Role - Lambda Execution
import {
  to = aws_iam_role.lambda_execution
  id = "${local.import_name_prefix}-lambda-execution"
}

# IAM Policy - Lambda DynamoDB Access
import {
  to = aws_iam_policy.lambda_dynamodb
  id = "arn:aws:iam::${data.aws_caller_identity.current.account_id}:policy/${local.import_name_prefix}-lambda-dynamodb"
}

# IAM Policy - Lambda S3 Access
import {
  to = aws_iam_policy.lambda_s3
  id = "arn:aws:iam::${data.aws_caller_identity.current.account_id}:policy/${local.import_name_prefix}-lambda-s3"
}

# IAM Policy - Lambda SQS Access
import {
  to = aws_iam_policy.lambda_sqs
  id = "arn:aws:iam::${data.aws_caller_identity.current.account_id}:policy/${local.import_name_prefix}-lambda-sqs"
}

# IAM Policy - Lambda SES Access
import {
  to = aws_iam_policy.lambda_ses
  id = "arn:aws:iam::${data.aws_caller_identity.current.account_id}:policy/${local.import_name_prefix}-lambda-ses"
}

# IAM Policy - Lambda Secrets Manager Access
import {
  to = aws_iam_policy.lambda_secrets
  id = "arn:aws:iam::${data.aws_caller_identity.current.account_id}:policy/${local.import_name_prefix}-lambda-secrets"
}

# IAM Role - API Gateway CloudWatch (conditional resource - REMOVED FROM IMPORT.TF)
# This import block has been removed because it references a conditional resource (count-based).
# If manage_account_settings = false in the API Gateway module, the resource doesn't exist
# in the Terraform configuration, causing import blocks to fail during terraform plan.
# This resource is imported by the import-resources.sh script instead, which handles
# conditional resources gracefully by checking if they exist in AWS first.
#
# If you need to manually import this resource:
#   terraform import module.api_gateway.aws_iam_role.api_gateway_cloudwatch[0] <role-name>

# CloudWatch Log Group - API Gateway (conditional resource - REMOVED FROM IMPORT.TF)
# This import block has been removed because it references a conditional resource (count-based).
# If enable_api_gateway_logging = false, the resource doesn't exist in the configuration,
# causing import blocks to fail during terraform plan.
# This resource is imported by the import-resources.sh script instead.
#
# If you need to manually import this resource:
#   terraform import module.api_gateway.aws_cloudwatch_log_group.api_gateway[0] <log-group-name>

# Cognito User Pool Domain (REMOVED FROM IMPORT.TF - handled by import-resources.sh)
# This import block has been removed because Cognito imports require dynamic lookups.
# The user pool ID must be looked up by name, and the domain depends on the pool being
# imported first. The import-resources.sh script handles this correctly by:
# 1. Looking up the user pool ID by name
# 2. Importing the user pool first
# 3. Looking up the client ID
# 4. Importing the client
# 5. Finally importing the domain
#
# If you need to manually import these resources:
#   USER_POOL_ID=$(aws cognito-idp list-user-pools --max-results 60 --query "UserPools[?Name=='duemate-production-users'].Id" --output text)
#   terraform import module.cognito.aws_cognito_user_pool.main $USER_POOL_ID
#   CLIENT_ID=$(aws cognito-idp list-user-pool-clients --user-pool-id $USER_POOL_ID --max-results 60 --query "UserPoolClients[0].ClientId" --output text)
#   terraform import module.cognito.aws_cognito_user_pool_client.main $USER_POOL_ID/$CLIENT_ID
#   terraform import module.cognito.aws_cognito_user_pool_domain.main duemate-production-users
# 
# Replace 'duemate-production' with your actual name prefix (${project_name}-${environment})

# DynamoDB Table
import {
  to = module.dynamodb.aws_dynamodb_table.main
  id = "${local.import_name_prefix}-main"
}

# S3 Bucket - Frontend
import {
  to = module.s3.aws_s3_bucket.frontend
  id = "${local.import_name_prefix}-frontend"
}

# S3 Bucket - Invoices
import {
  to = module.s3.aws_s3_bucket.invoices
  id = "${local.import_name_prefix}-invoices"
}

# S3 Bucket - Assets
import {
  to = module.s3.aws_s3_bucket.assets
  id = "${local.import_name_prefix}-assets"
}

# Lambda Function - Invoice Create
import {
  to = module.lambda_functions.aws_lambda_function.invoice_create
  id = "${local.import_name_prefix}-invoice-create"
}

# CloudWatch Log Group - Invoice Create
import {
  to = module.lambda_functions.aws_cloudwatch_log_group.invoice_create
  id = "/aws/lambda/${local.import_name_prefix}-invoice-create"
}

# Lambda Function - Invoice Get
import {
  to = module.lambda_functions.aws_lambda_function.invoice_get
  id = "${local.import_name_prefix}-invoice-get"
}

# CloudWatch Log Group - Invoice Get
import {
  to = module.lambda_functions.aws_cloudwatch_log_group.invoice_get
  id = "/aws/lambda/${local.import_name_prefix}-invoice-get"
}

# Lambda Function - Reminder Check
import {
  to = module.lambda_functions.aws_lambda_function.reminder_check
  id = "${local.import_name_prefix}-reminder-check"
}

# CloudWatch Log Group - Reminder Check
import {
  to = module.lambda_functions.aws_cloudwatch_log_group.reminder_check
  id = "/aws/lambda/${local.import_name_prefix}-reminder-check"
}

# Lambda Function - Notification Worker
import {
  to = module.lambda_functions.aws_lambda_function.notification_worker
  id = "${local.import_name_prefix}-notification-worker"
}

# CloudWatch Log Group - Notification Worker
import {
  to = module.lambda_functions.aws_cloudwatch_log_group.notification_worker
  id = "/aws/lambda/${local.import_name_prefix}-notification-worker"
}

# EventBridge Rule - Reminder Check
import {
  to = module.eventbridge.aws_cloudwatch_event_rule.reminder_check
  id = "${local.import_name_prefix}-reminder-check"
}

# EventBridge Target - Reminder Check
import {
  to = module.eventbridge.aws_cloudwatch_event_target.reminder_check
  id = "${local.import_name_prefix}-reminder-check/ReminderCheckLambda"
}

# Lambda Permission - EventBridge to invoke Reminder Check
import {
  to = module.eventbridge.aws_lambda_permission.allow_eventbridge
  id = "${local.import_name_prefix}-reminder-check/${local.import_name_prefix}-AllowExecutionFromEventBridge"
}
